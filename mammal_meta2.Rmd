---
title: "NJ mammal metabarcoding"
author: "Mike Allen"
date: "1/11/2022"
output: html_document
---
# Load libraries and data formatting
```{r}
library(readxl)
library(dplyr)
library(tidyr)
library(ggplot2)
library(BiodiversityR) # also loads vegan
'%notin%' <- Negate('%in%')

# read in raw read data
m_raw <- 
  readxl::read_xlsx("data/table.c10.complete.leib.xlsx")

# read in taxonomy file
tax <- read.csv("data/taxonomy.csv")

# read in sample list
samps <- read_xlsx("data/sample_list.xlsx")
samps2 <- read_xlsx("data/Exxon Bat 2021.xlsx", sheet = "Tree  Sample Data") %>%
  mutate(tree = c(paste0("T0", 1:9), paste0("T",10:21)))

# clean version summarized by OTU
m_otu <- m_raw %>%
  select(species, psim = "percent similarity",  
         starts_with("sample")) %>%
  mutate(method = case_when(psim <= 1 ~ "libraries",
                            TRUE ~ "BLAST"),
         psim = case_when(psim <= 1 ~ psim*100,
                          TRUE ~ psim)) %>%
# exclude Gallus gallus and 4 genera not found in region
  filter(species %notin% c("Gallus gallus", 
                           "Pudu mephistophiles, Mazama rufina",
                           "Leuconotopicus albolarvatus"),
         grepl(species, pattern = "Emberiza") == FALSE) %>%
  # clean up species names
  mutate(species = 
           case_when(species == "Euphagus cyanocephalus" ~ 
                       "Euphagus sp.",
                     grepl(species, 
                           pattern = "Microtus") ~ 
                       "Microtus sp.",
                     grepl(species, pattern = "Sciurius") ~ 
                       "Sciurus carolinensis",
                     grepl(species, pattern = "Sciurus") ~
                             "Sciurus carolinensis",
                     species == "Canis lupus" ~ 
                       "Canis lupus familiares",
                     grepl(species, pattern = "Vulpes vulpes") ~
                             "Vulpes vulpes",
                     TRUE ~ species)) %>%
  arrange(species) %>%
  left_join(tax, by = "species") %>%
  select(common, psim, starts_with("Sample"))

m_otu_tax <- m_otu %>%
  left_join(tax) %>%
  mutate(lineage = paste0("r__Chordata;c__", class, ";o__", order, ";f__", fam, ";g__", genus, ";s__", sp))

# make data version for archiving
m_otu_archive <- m_otu_tax %>%
  group_by(common) %>%
  mutate(
    num = 1:length(species)) %>%
  ungroup() %>%
  mutate(
    num2 = ifelse(nchar(num)==1, paste0("0",num), num),
    OTU_num = paste0(
    gsub(species, pattern = " ", replacement = "_"),
    "_", num2) ) %>%
  select(OTU_num, common, order, class, family = fam, species, psim, 
         starts_with("sample"))

write.csv(m_otu_archive, "data/OTU_table.csv", row.names = F)
rm(m_otu_archive)

# removing psim (not needed anymore)
m_otu <- m_otu %>%
  select(-psim)

m_otu_tax <- m_otu_tax %>%
  select(-psim)

# clean version summarized by species
m_sp_temp <- m_otu %>%
  group_by(common) %>%
  summarize_all(sum) %>%
  arrange(common)
  
m_flip <- m_sp_temp %>%
  t() %>%
  as.data.frame()
m_flip$sample <- rownames(m_flip)

# create all the sample names
roller_samples1 <-
  lapply(1:3, function(x)
    paste0("sample:R0", 1:9, LETTERS[x]))
roller_samples2 <-
  lapply(1:3, function(x)
    paste0("sample:R", 10:21, LETTERS[x]))
soil_samples1 <-
  lapply(1:3, function(x)
    paste0("sample:S0", 1:9, LETTERS[x]))
soil_samples2 <-
  lapply(1:3, function(x)
    paste0("sample:S", 10:21, LETTERS[x]))

m_sp_temp2 <- data.frame(sample = c(do.call(c, roller_samples1),
                    do.call(c, roller_samples2),
                    do.call(c, soil_samples1),
                    do.call(c, soil_samples2))) %>%
  arrange(sample) %>%
  left_join(m_flip, by = "sample") %>%
  replace(is.na(.), 0) %>%
  mutate(tree = paste0("T",substr(sample, 9, 10)),
         visit = substr(sample, 11, 11), 
         method = substr(sample, 8, 8),
         site = substr(sample, 8, 10)) %>%
  select(tree, visit, method, site, starts_with("V"))
colnames(m_sp_temp2) <-
  c("tree", "visit", "method", "site",
    gsub(gsub(m_sp_temp$common, pattern = " ", replacement = "_"),
         pattern = ",", replacement = ""))

# make temporary full version of species site matrix
tmp_sp <- m_sp_temp2 %>%
  select("American_Red_Squirrel":"Yellow-rumped_Warbler")
sp_mat_temp <- matrix(as.numeric(as.matrix(tmp_sp)), 
                   nrow = 126, ncol = ncol(tmp_sp),
                    byrow = F) %>%
  as.data.frame()
colnames(sp_mat_temp) <- colnames(tmp_sp)
rm(tmp_sp)

m_sp <- cbind.data.frame(m_sp_temp2[,1:4], sp_mat_temp) %>%
  arrange(tree, visit, site) %>%
  filter(paste0(site,visit) %in% samps$`Sample ID`) %>%
  group_by(tree) %>%
  mutate(samp_num = 1:length(tree))

# make final site by species matrix
sp_mat <- sp_mat_temp[which(paste0(m_sp_temp2$site,m_sp_temp2$visit) %in% samps$`Sample ID`),]

# define sample size variables
n_trees <- length(unique(m_sp$tree))
nspec <- ncol(sp_mat)
n_visits <- max(tally(m_sp %>% group_by(tree))$n) # max visits/tree
n_samples <- nrow(m_sp)

# create array for multispecies occupancy modelling
# dims: sites, visits, species with 
m_sp_array <- array(NA, dim = c(n_trees, n_visits, nspec))
for(s in 1:nspec){
  for(samp in 1:n_samples){
    tree_num <- as.numeric(as.factor(m_sp$tree))[samp]
    samp_num <- m_sp$samp_num[samp]
      m_sp_array[tree_num, samp_num, s] <- 
        as.numeric(m_sp[samp, s+4])
      }
  }
  
# convert array to detection/non-detection
m_sp_detnon <- m_sp_array
m_sp_detnon[m_sp_detnon>0] <- 1  
y <- m_sp_detnon # rename for occupancy model

# create visit-level covariate matrices
method_mat <- matrix(NA, nrow = n_trees, ncol = n_visits)
for(samp in 1:n_samples){
    tree_num <- as.numeric(as.factor(m_sp$tree))[samp]
    samp_num <- m_sp$samp_num[samp]
      method_mat[tree_num, samp_num] <- 
        as.numeric(as.factor(m_sp$method))[samp]
      }
method_mat[method_mat==2] <- 0 # make roller = 1, soil = 0

# remove unneeded objects
rm(m_sp_temp, m_sp_temp2, m_flip, roller_samples1, roller_samples2, soil_samples1, soil_samples2, sp_mat_temp)

# Get observed number of species per site
tmp <- apply(y, c(1,3), max, na.rm = TRUE)
tmp[tmp == "-Inf"] <- NA
sort(C <- apply(tmp, 1, sum)) # Compute and print sorted species counts

# Observed number of occupied sites per species
tmp <- apply(y, c(1,3), max, na.rm = TRUE)
# For the 'all NA' site, max returns -Inf with a warning
tmp[tmp == -Inf] <- NA         # Change -Inf to NA
sort(obs.occ <- apply(tmp, 2, sum, na.rm = TRUE))
names(obs.occ) <- colnames(m_sp)[5:(nspec+4)]

# Collapse 3D detection/nondetection data to 2D detection frequencies
ysum <- apply(y, c(1,3), sum, na.rm = T) 

# number of visits per tree
J <- summarize(m_sp %>% group_by(tree), J = max(samp_num))$J

# subset detection/non-detection array to just mammals
y_mam <- y[,,c(1,3,5:12,14:15,18:21)]

rm(tmp)

# Format occupancy data using subset of roller samples to match soil

m_sp.r <- m_sp %>% # r for "reduced"
  group_by(tree, visit) %>%
  mutate(n_samps = length(method)) %>%
  filter(n_samps > 1) %>%
  ungroup() %>%
  group_by(tree) %>%
  mutate(samp_num = 1:length(tree)) %>%
  ungroup()

# define sample size variables
n_trees.r <- length(unique(m_sp.r$tree))
nspec.r <- ncol(sp_mat)
n_visits.r <- max(tally(m_sp.r %>% group_by(tree))$n) # max visits/tree
n_samples.r <- nrow(m_sp.r)

# create array for multispecies occupancy modelling (reduced dataset)
# dims: sites, visits, species with 
m_sp_array.r <- array(NA, dim = c(n_trees.r, n_visits.r, nspec.r))
for(s in 1:nspec.r){
  for(samp in 1:n_samples.r){
    tree_num.r <- as.numeric(as.factor(m_sp.r$tree))[samp]
    samp_num.r <- m_sp.r$samp_num[samp]
      m_sp_array.r[tree_num.r, samp_num.r, s] <- 
        as.numeric(m_sp.r[samp, s+4])
      }
  }
  
# convert array to detection/non-detection
m_sp_detnon.r <- m_sp_array.r
m_sp_detnon.r[m_sp_detnon.r > 0] <- 1  
y.r <- m_sp_detnon.r # rename for occupancy model

# create visit-level covariate matrices
method_mat.r <- matrix(NA, nrow = n_trees.r, ncol = n_visits.r)
for(samp in 1:n_samples.r){
    tree_num.r <- as.numeric(as.factor(m_sp.r$tree))[samp]
    samp_num.r <- m_sp.r$samp_num[samp]
      method_mat.r[tree_num.r, samp_num.r] <- 
        as.numeric(as.factor(m_sp.r$method))[samp]
      }
method_mat.r[method_mat.r==2] <- 0 # make roller = 1, soil = 0

# number of visits per tree (reduced dataset)
J.r <- summarize(m_sp.r %>% group_by(tree), J.r = max(samp_num))$J.r

# subset detection/non-detection array to just mammals
y_mam.r <- y.r[,,c(3,5:9,11:12,14:15,18:21)]
colnames(m_sp.r[,c(3,5:9,11:12,14:15,18:21)+4])
apply(y_mam.r, 3, sum, na.rm = T)
```
# Create Fig. 1B - read counts
Also, tally reads for different groups.
```{r}
mean_reads <- m_sp %>%
  group_by(method) %>%
    select_if(is.numeric) %>%
  summarize_all(mean) %>%
  select(-samp_num, -method) %>%
  t() %>%
  as.data.frame()

# count samples in each method (R = 59, S = 35)
n_samples <- m_sp %>%
  group_by(method) %>%
    tally()

num_with_reads <- m_sp %>%
  group_by(method) %>%
    select_if(is.numeric) %>%
  summarize_all(.funs = function(x) sum(x>0)) %>%
  select(-samp_num, -method) %>%
  t()

nspec <- ncol(sp_mat)

mean_reads_df <- 
  data.frame(
    species = gsub(rep(rownames(mean_reads), 2), 
                   pattern = "_", replacement = " "),
  Method = c(rep("Roller", nspec), rep("Soil", nspec)),
  mean_reads = c(mean_reads[, 1], mean_reads[, 2]),
  prop_reads = c(num_with_reads[, 1] / 59,
                 num_with_reads[, 2] / 35)
)  %>%
  group_by(species) %>%
  mutate(sum_mean_reads = sum(mean_reads)) %>%
  ungroup() %>%
  mutate(species =
           forcats::fct_reorder(species, sum_mean_reads)) %>%
  filter(
    species %notin% c(
      "American Robin",
      "Red-bellied Woodpecker",
      "Mourning Dove",
      "Wild Turkey",
      "Blackbird sp.",
      "Yellow-rumped Warbler",
      "Red-backed Salamander"
    )
  ) %>%
  mutate(
    arboreal = rep(
      c("*", "*", "", "", "", "", "*", "",
        "*", "*", "*", "*", "", "", "*", ""),
      2
    ),
    species = paste0(species, arboreal),
    species =
      forcats::fct_reorder(species, sum_mean_reads)
  )


# plot mean reads
mean_reads_df %>%
  ggplot() +
  geom_col(aes(x = mean_reads+1, y = species, fill = Method),
           position = position_dodge()) +
  scale_fill_manual(values = c("black", "gray")) +
  theme_bw() +
  theme(text = element_text(size = 14)) +
  labs(y = "", x = "Mean number of reads") +
  scale_x_log10()
ggsave("figures/mean_reads_by_species_method_mammals2.png", 
       height = 5,
       width = 7, dpi = 400)

# get mean reads by method for non-bat arboreal/non-arboreal
mean_reads_df %>%
  filter(species %notin% c("E. small-footed myotis",
                           "Big Brown Bat*")) %>%
  group_by(Method, arboreal) %>%
  summarise(mean_mean = mean(mean_reads),
            min_mean = min(mean_reads),
            max_mean = max(mean_reads),
            sd_mean = sd(mean_reads),
            n = length(mean_reads),
            se = sd_mean/sqrt(n))

# get mean reads by method for bats
mean_reads_df %>%
  filter(species %in% c("E. small-footed myotis",
                           "Big Brown Bat*")) %>%
  group_by(Method) %>%
  summarise(mean_mean = mean(mean_reads),
            min_mean = min(mean_reads),
            max_mean = max(mean_reads),            
            sd_mean = sd(mean_reads),
            n = length(mean_reads),
            se = sd_mean/sqrt(n))

# get overall mean for arboreal vs. non-arboreal
mean_reads_df %>%
  group_by(arboreal) %>%
  summarise(mean_mean = mean(mean_reads),
            min_mean = min(mean_reads),
            max_mean = max(mean_reads),
            sd_mean = sd(mean_reads),
            n = length(mean_reads),
            se = sd_mean/sqrt(n))

# get overall mean by method for arboreal vs. non-arboreal
mean_reads_df %>%
  group_by(Method, arboreal) %>%
  summarise(mean_mean = mean(mean_reads),
            min_mean = min(mean_reads),
            max_mean = max(mean_reads),
            sd_mean = sd(mean_reads),
            n = length(mean_reads),
            se = sd_mean/sqrt(n))
```
# Create Fig. 2 - heat trees
```{r}
# load packages
library(taxa)
library(metacoder)

# format data for heat trees
use_common_name = 1

if(use_common_name == 1){
obj <- parse_tax_data(m_otu_tax,
                      class_cols = c(72:75,1)) 
}else{
obj <- parse_tax_data(m_otu_tax,
                      class_cols = c(72:76)) 
}

# convert to proportions
# obj$data$tax_data <- calc_obs_props(obj, "tax_data")

Method <- substr(colnames(m_otu)[2:length(colnames(m_otu))],8,8)
Samples <- colnames(m_otu)[2:length(colnames(m_otu))]

#Getting per-taxon information
obj$data$tax_abund <- calc_taxon_abund(obj, "tax_data",
                                       cols = Samples,
                                       groups = Method)
obj$data$tax_abund$Soil_per <- obj$data$tax_abund$S/23
obj$data$tax_abund$Roller_per <- obj$data$tax_abund$R/46

#Getting per-taxon information for 'number of samples'
obj$data$tax_abund1 <- calc_taxon_abund(obj, "tax_data", 
                                        cols = Samples)

# calculate the number of samples that have reads for each taxon
obj$data$tax_occ <- calc_n_samples(obj, "tax_abund1", groups = Method, cols = Samples)

# calculate the number of methods that detected each taxon
obj$data$tax_occ$num_methods <- (obj$data$tax_occ$S>0) +
  (obj$data$tax_occ$R>0)

# calculate mean number of taxa detected across all methods
obj$data$tax_abund$All_per <- (obj$data$tax_abund$Soil_per +
  obj$data$tax_abund$Roller_per)/2

# Make soil heat tree
set.seed(1) # This makes the plot appear the same each time it is run 
(soil <- heat_tree(obj, 
          node_label = taxon_names,
          node_size = obj$data$tax_abund$Soil_per,
          node_color = 100*obj$data$tax_occ$S/23, 
          node_color_digits = 2,
          node_color_trans = "linear",
          node_label_size_range = c(0.025, 0.05),
          node_color_interval = c(0,100),
          node_size_axis_label = "Mean reads / sample",
          node_color_axis_label = "% samples with reads",
          layout = "davidson-harel", # The primary layout algorithm
          initial_layout = "reingold-tilford") +
    theme(plot.margin=unit(c(-1,0,-1,0), "cm")) +
    annotate(geom = "text", x = .9, y = .9, label = "Soil", size = 9)
  )
 # ggsave("figures/Soil_heattree_abund2.jpg",
 # width = 7, height = 7, dpi = 400)

# Make roller heat tree
set.seed(1) # This makes the plot appear the same each time it is run 
(roller <- heat_tree(obj, 
          node_label = taxon_names,
          node_size = obj$data$tax_abund$Roller_per,
          node_color = 100*obj$data$tax_occ$R/46,
          node_color_digits = 2,
          node_color_trans = "linear",
          node_label_size_range = c(0.025, 0.05),
          node_color_interval = c(0,100),
          node_size_axis_label = "Mean reads / sample",
          node_color_axis_label = "% samples with reads",
          layout = "davidson-harel", # The primary layout algorithm
          initial_layout = "reingold-tilford") %>%
  + theme(plot.margin=unit(c(-1,0,-1,0), "cm")) +
    annotate(geom = "text", x = .9, y = .9, label = "Roller", size = 9)
  )
# ggsave("figures/Roller_heattree_abund2.jpg", width = 7, height = 7, dpi = 400)

# 2-panel figure
g <- gridExtra::grid.arrange(roller, soil, ncol = 2)

ggsave("figures/Fig2_heat_tree_collage_2.5_5pct.jpg", g,
       height = 9, width = 15, dpi = 400)
```
# Create Fig. 3 - mammal species accumulation curves 
Code adapted from: https://rpubs.com/Roeland-KINDT/694021
and: http://biological-complexity.blogspot.com/2018/01/on-species-accumulation-curves.html
```{r}
# Make empty martices for the spp accumulation curves
roll_mat_1samp = matrix(NA, nrow = 21, ncol = 16)
soil_mat_1samp = matrix(NA, nrow = 21, ncol = 16)
both_mat_1samp = matrix(NA, nrow = 21, ncol = 16)

roll_mat_2samp = matrix(NA, nrow = 21, ncol = 16)
soil_mat_2samp = matrix(NA, nrow = 21, ncol = 16)
both_mat_2samp = matrix(NA, nrow = 21, ncol = 16)

roll_mat_3samp = matrix(NA, nrow = 21, ncol = 16)
soil_mat_3samp = matrix(NA, nrow = 21, ncol = 16)
both_mat_3samp = matrix(NA, nrow = 21, ncol = 16)

# Fill matrices with detection/nondetection data by tree and species
for(j in 1:16){
  print(paste0("species:",j))
for(i in 1:21){
roll_mat_1samp[i,j] = y_mam[i,,j][method_mat[i,]==1][1]
soil_mat_1samp[i,j] = y_mam[i,,j][method_mat[i,]==0][1]
both_mat_1samp[i,j] = max(roll_mat_1samp[i,j], soil_mat_1samp[i,j])

roll_mat_2samp[i,j] = max(y_mam[i,,j][method_mat[i,]==1][1:2])
soil_mat_2samp[i,j] = max(y_mam[i,,j][method_mat[i,]==0][1:2])
both_mat_2samp[i,j] = max(roll_mat_2samp[i,j], soil_mat_2samp[i,j])

roll_mat_3samp[i,j]=max(y_mam[i,,j][method_mat[i,]==1][1:3])
soil_mat_3samp[i,j]=max(y_mam[i,,j][method_mat[i,]==0][1:3])
both_mat_3samp[i,j] = max(roll_mat_3samp[i,j], soil_mat_3samp[i,j])
  }
}

# remove rows with all NAs
roll_mat_2samp = roll_mat_2samp[is.na(roll_mat_2samp[,1])==F,]
roll_mat_3samp = roll_mat_3samp[is.na(roll_mat_3samp[,1])==F,]
soil_mat_1samp = soil_mat_1samp[is.na(soil_mat_1samp[,1])==F,]
soil_mat_2samp = soil_mat_2samp[is.na(soil_mat_2samp[,1])==F,]
soil_mat_3samp = soil_mat_3samp[is.na(soil_mat_3samp[,1])==F,]
both_mat_1samp = both_mat_1samp[is.na(both_mat_1samp[,1])==F,]
both_mat_2samp = both_mat_2samp[is.na(both_mat_2samp[,1])==F,]
both_mat_3samp = both_mat_3samp[is.na(both_mat_3samp[,1])==F,]

# run species accumulation curves
accum.roll1 <- accumcomp(roll_mat_1samp, 
                     y=data.frame(method = 
                                    rep("roll1",
                                        nrow(roll_mat_1samp))),
                     factor='method', 
  method='exact', conditioned=FALSE, plotit=FALSE)
accum.roll1

accum.roll2 <- accumcomp(roll_mat_2samp, 
                     y=data.frame(method = 
                                    rep("roll2",
                                        nrow(roll_mat_2samp))),
                     factor='method', 
  method='exact', conditioned=FALSE, plotit=FALSE)
accum.roll2

accum.roll3 <- accumcomp(roll_mat_3samp, 
                     y=data.frame(method = 
                                    rep("roll3",
                                        nrow(roll_mat_3samp))),
                     factor='method', 
  method='exact', conditioned=FALSE, plotit=FALSE)
accum.roll3

accum.soil1 <- accumcomp(soil_mat_1samp, 
                         y=data.frame(method = 
                                        rep("soil1",
                                            nrow(soil_mat_1samp))),
                         factor='method', 
                         method='exact', conditioned=FALSE, plotit=FALSE)
accum.soil1

accum.soil2 <- accumcomp(soil_mat_2samp, 
                         y=data.frame(method = 
                                        rep("soil2",
                                            nrow(soil_mat_2samp))),
                         factor='method', 
                         method='exact', conditioned=FALSE, plotit=FALSE)
accum.soil2

accum.soil3 <- accumcomp(soil_mat_3samp, 
                         y=data.frame(method = 
                                        rep("soil3",
                                            nrow(soil_mat_3samp))),
                         factor='method', 
                         method='exact', conditioned=FALSE, plotit=FALSE)
accum.soil3

accum.both1 <- accumcomp(both_mat_1samp, 
                         y=data.frame(method = 
                                        rep("both1",
                                            nrow(both_mat_1samp))),
                         factor='method', 
                         method='exact', conditioned=FALSE, plotit=FALSE)
accum.both1

accum.both2 <- accumcomp(both_mat_2samp, 
                         y=data.frame(method = 
                                        rep("both2",
                                            nrow(both_mat_2samp))),
                         factor='method', 
                         method='exact', conditioned=FALSE, plotit=FALSE)
accum.both2

accum.both3 <- accumcomp(both_mat_3samp, 
                         y=data.frame(method = 
                                        rep("both3",
                                            nrow(both_mat_3samp))),
                         factor='method', 
                         method='exact', conditioned=FALSE, plotit=FALSE)
accum.both3

# format results to plot the curves
plot.data.roll1 <- data.frame(samples = c(accum.roll1[,,1]), 
           s = c(accum.roll1[,,2]), 
           sd = c(accum.roll1[,,3]),
           method = "roll1")
plot.data.roll2 <- data.frame(samples = c(accum.roll2[,,1]), 
           s = c(accum.roll2[,,2]), 
           sd = c(accum.roll2[,,3]),
           method = "roll2")
plot.data.roll3 <- data.frame(samples = c(accum.roll3[,,1]), 
           s = c(accum.roll3[,,2]), 
           sd = c(accum.roll3[,,3]),
           method = "roll3")
plot.data.soil1 <- data.frame(samples = c(accum.soil1[,,1]), 
            s = c(accum.soil1[,,2]), 
            sd = c(accum.soil1[,,3]),
            method = "soil1")
plot.data.soil2 <- data.frame(samples = c(accum.soil2[,,1]), 
            s = c(accum.soil2[,,2]), 
            sd = c(accum.soil2[,,3]),
            method = "soil2")
plot.data.soil3 <- data.frame(samples = c(accum.soil3[,,1]), 
            s = c(accum.soil3[,,2]), 
            sd = c(accum.soil3[,,3]),
            method = "soil3")
plot.data.both1 <- data.frame(samples = c(accum.both1[,,1]), 
            s = c(accum.both1[,,2]), 
            sd = c(accum.both1[,,3]),
            method = "both1")
plot.data.both2 <- data.frame(samples = c(accum.both2[,,1]), 
            s = c(accum.both2[,,2]), 
            sd = c(accum.both2[,,3]),
            method = "both2")
plot.data.both3 <- data.frame(samples = c(accum.both3[,,1]), 
            s = c(accum.both3[,,2]), 
            sd = c(accum.both3[,,3]),
            method = "both3")

plot.data <- plot.data.roll1 %>%
  bind_rows(plot.data.roll2) %>%
  bind_rows(plot.data.roll3) %>%
  bind_rows(plot.data.soil1) %>%
  bind_rows(plot.data.soil2) %>%
  bind_rows(plot.data.soil3) %>%
  bind_rows(plot.data.both1) %>%
  bind_rows(plot.data.both2) %>%
  bind_rows(plot.data.both3) %>%
  mutate(method = as.factor(method),
         Method = substr(method, 1, 4),
         per_tree = paste0(substr(method, 5,5), 
                           " samples per tree")) %>%
  mutate(Method = case_when(Method == "both" ~ "Both",
                            Method == "roll" ~ "Roller",
                            Method == "soil" ~ "Soil"),
         per_tree = case_when(per_tree == "1 samples per tree" ~
                                "1 sample per tree",
                              TRUE ~ per_tree)) 
  
plot.data %>%
ggplot() +
  geom_ribbon(aes(x = samples, ymin = s-1*sd, 
                  ymax = s+1*sd, fill = Method, group = method),
              alpha = 0.5) +  
  geom_line(aes(x = samples, y = s, group = method, lty = Method), size = 1) +
  scale_fill_manual(values = c("darkgreen", "steelblue", "firebrick")) +
  facet_wrap(~per_tree) +
  theme_bw() +
  theme(text = element_text(size = 14),
        legend.position = c(.92,.15),
        legend.key.size = unit(.2, 'cm'),
        legend.background = element_rect(fill = "transparent"),
        strip.background = element_rect(fill = "white")) +
  labs(x = "No. trees sampled", y = "No. mammal species",
       fill = "Method")


ggsave("figures/Fig3_species_accumulation_curve_roll_soil4.png",
       dpi = 600, width = 6, height = 4)
```
# Run Dorazio-Royle community occupancy model
Community occupancy model on only mammals. Code adapted from Kery and Royle, AMH 1 book, section 11.7.2.
```{r}
# update n species
nspec <- dim(y_mam)[3]

# Augment data set: choose one of two different priors on Ntotal
nz <- 40 - nspec         
# Use for informative prior on Ntotal
# M = ~40 ("dozens of mammal species" - NJDEP)

# changing NA in method matrix to 0 so model can run 
# (not actually missing)
method_mat0 <- method_mat; method_mat0[is.na(method_mat0)] <- 0

nsite <- n_trees; nrep <- n_visits
yaug <- array(0, dim=c(nsite, nrep, nspec+nz)) # array with only zeroes
yaug[,,1:nspec] <- y_mam      # copy into it the observed data

# Create same NA pattern in augmented species as in the observed species
missings <- is.na(yaug[,,1]) 
for(k in (nspec+1):(nspec+nz)){
  yaug[,,k][missings] <- NA
}

# Bundle and summarize data
str(win.data <- list(y = yaug, nsite = dim(y_mam)[1], nrep = dim(y_mam)[2], nspec = dim(y_mam)[3], nz = nz, M = nspec + nz, method = method_mat0) )

# Specify model in BUGS language
sink("scripts/DR_psi._p.method.txt")
cat("
model {

# Priors
omega ~ dunif(0,1)
# Priors for species-specific effects in occupancy and detection
for(k in 1:M){
  lpsi[k] ~ dnorm(mu.lpsi, tau.lpsi)    # Hyperparams describe community
  # betalpsi1[k] ~ dnorm(mu.betalpsi1, tau.betalpsi1)
  # betalpsi2[k] ~ dnorm(mu.betalpsi2, tau.betalpsi2)
  # betalpsi3[k] ~ dnorm(mu.betalpsi3, tau.betalpsi3)
  lp[k] ~ dnorm(mu.lp, tau.lp)
  betalp1[k] ~ dnorm(mu.betalp1, tau.betalp1)
  # betalp2[k] ~ dnorm(mu.betalp2, tau.betalp2)
  # betalp3[k] ~ dnorm(mu.betalp3, tau.betalp3)
}

# Hyperpriors
# For the model of occupancy
mu.lpsi ~ dnorm(0,0.01)
tau.lpsi <- pow(sd.lpsi, -2)
sd.lpsi ~ dunif(0,8)   # as always, bounds of uniform chosen by trial and error
# mu.betalpsi1 ~ dnorm(0,0.1)
# tau.betalpsi1 <- pow(sd.betalpsi1, -2)
# sd.betalpsi1 ~ dunif(0, 4)
# mu.betalpsi2 ~ dnorm(0,0.1)
# tau.betalpsi2 <- pow(sd.betalpsi2, -2)
# sd.betalpsi2 ~ dunif(0,2)
# mu.betalpsi3 ~ dnorm(0,0.1)
# tau.betalpsi3 <- pow(sd.betalpsi3, -2)
# sd.betalpsi3 ~ dunif(0,2)

# For the model of detection
mu.lp ~ dnorm(0,0.1)
tau.lp <- pow(sd.lp, -2)
sd.lp ~ dunif(0, 2)
mu.betalp1 ~ dnorm(0,0.1)
tau.betalp1 <- pow(sd.betalp1, -2)
sd.betalp1 ~ dunif(0,1)
# mu.betalp2 ~ dnorm(0,0.1)
# tau.betalp2 <- pow(sd.betalp2, -2)
# sd.betalp2 ~ dunif(0,1)
# mu.betalp3 ~ dnorm(0,0.1)
# tau.betalp3 <- pow(sd.betalp3, -2)
# sd.betalp3 ~ dunif(0,1)

# Superpopulation process: Ntotal species sampled out of M available
for(k in 1:M){
   w[k] ~ dbern(omega)
}

# Ecological model for true occurrence (process model)
for(k in 1:M){
  for (i in 1:nsite) {
    logit(psi[i,k]) <- lpsi[k] #+ betalpsi1[k] * ele[i] +
      #betalpsi2[k] * pow(ele[i],2) + betalpsi3[k] * forest[i]
    mu.psi[i,k] <- w[k] * psi[i,k]
    z[i,k] ~ dbern(mu.psi[i,k])
  }
}

# Observation model for replicated detection/nondetection observations
for(k in 1:M){
  for (i in 1:nsite){
    for(j in 1:nrep){
      logit(p[i,j,k]) <- lp[k] + betalp1[k] * method[i,j] #+
        #betalp2[k] * pow(DAT[i,j],2) + betalp3[k] * DUR[i,j]
      mu.p[i,j,k] <- z[i,k] * p[i,j,k]
      y[i,j,k] ~ dbern(mu.p[i,j,k])
    }
  }
}

# Derived quantities
#for(k in 1:M){
#   Nocc.fs[k] <- sum(z[,k])       # Number of occupied sites among the 267
#}
for (i in 1:nsite){
   Nsite[i] <- sum(z[i,])          # Number of occurring species at each site
}
n0 <- sum(w[(nspec+1):(nspec+nz)]) # Number of unseen species
Ntotal <- sum(w[])                 # Total metacommunity size

# Vectors to save (S for ?save?; discard posterior samples for
# all minus 1 of the potential species to save disk space)
# we do this for nz = 250 (i.e., M = 395)
# lpsiS[1:(nspec+1)] <- lpsi[1:(nspec+1)]
# betalpsi1S[1:(nspec+1)] <- betalpsi1[1:(nspec+1)]
# betalpsi2S[1:(nspec+1)] <- betalpsi2[1:(nspec+1)]
# betalpsi3S[1:(nspec+1)] <- betalpsi3[1:(nspec+1)]
# lpS[1:(nspec+1)] <- lp[1:(nspec+1)]
# betalp1S[1:(nspec+1)] <- betalp1[1:(nspec+1)]
# betalp2S[1:(nspec+1)] <- betalp2[1:(nspec+1)]
# betalp3S[1:(nspec+1)] <- betalp3[1:(nspec+1)]
}
",fill = TRUE)
sink()

# Initial values
wst <- rep(1, nspec+nz)   # Simply set everybody at occurring
zst <- array(1, dim = c(nsite, nspec+nz)) # ditto
inits <- function() list(z = zst, w = wst, lpsi = rnorm(n = nspec+nz), betalpsi1 = rnorm(n = nspec+nz), betalpsi2 = rnorm(n = nspec+nz), betalpsi3 = rnorm(n = nspec+nz), lp = rnorm(n = nspec+nz), betalp1 = rnorm(n = nspec+nz), betalp2 = rnorm(n = nspec+nz), betalp3 = rnorm(n = nspec+nz))

# Set 1
params1 <- c("omega", "mu.lpsi", "sd.lpsi", "mu.betalpsi1", "sd.betalpsi1", "mu.betalpsi2", "sd.betalpsi2", "mu.betalpsi3", "sd.betalpsi3", "mu.lp", "sd.lp", "mu.betalp1", "sd.betalp1", "mu.betalp2", "sd.betalp2", "mu.betalp3", "sd.betalp3", "Ntotal", "Nsite")

# MCMC settings
ni <- 30000   ;   nt <- 10   ;   nb <- 10000   ;   nc <- 3

# Run JAGS, check convergence and summarize posteriors
DR_psi._p.method_partA <- jagsUI::jags(win.data, inits, params1, 
               "scripts/DR_psi._p.method.txt", 
               n.chains = nc, n.thin = nt, n.iter = ni, 
               n.burnin = nb, parallel = TRUE)
DR_psi._p.method_partA
dev.new(6,6); plot(DR_psi._p.method_partA)

par(mfrow = c(2, 2))
jagsUI::traceplot(DR_psi._p.method_partA, c(c("omega", "mu.lpsi", "sd.lpsi", "mu.betalpsi1", "sd.betalpsi1", "mu.betalpsi2", "sd.betalpsi2", "mu.betalpsi3", "sd.betalpsi3", "mu.lp", "sd.lp", "mu.betalp1", "sd.betalp1", "mu.betalp2", "sd.betalp2", "mu.betalp3", "sd.betalp3", "Ntotal")) )
# saveRDS(DR_psi._p.method_partA,
#         "output/DR_psi._p.method_partA2.rds")

# or load finished model from here to save time
DR_psi._p.method_partA <-
  readRDS("output/DR_psi._p.method_partA2.rds")

# Set 2
params2 <- c("mu.lpsi", "sd.lpsi", "mu.betalpsi1", "sd.betalpsi1", "mu.betalpsi2", "sd.betalpsi2", "mu.betalpsi3", "sd.betalpsi3", "lpsi", "betalpsi1", "betalpsi2", "betalpsi3", "lp", "betalp1", "betalp2", "betalp3", "z", "w")
ni <- 30000   ;   nt <- 10   ;   nb <- 10000   ;   nc <- 3
DR_psi._p.method_partB <- jagsUI::jags.basic(win.data, inits, params2, "scripts/DR_psi._p.method.txt", n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, parallel = TRUE)
# saveRDS(DR_psi._p.method_partB,
#         "output/DR_psi._p.method_partB2.rds")

# or load finished model from here to save time
DR_psi._p.method_partB <-
  readRDS("output/DR_psi._p.method_partB2.rds")

# summary(DR_psi._p.method_partB)            # May take a loooong time
# gelman.diag(DR_psi._p.method_partB)        # ditto

# look at parameter estimates
DR_psi._p.method_partA$summary[1:17,c(1:3, 7)]

out10 <- DR_psi._p.method_partA

# # Visualize covariate mean relationships for the average species
# # Get covariate values for prediction
# o.method <- c(1,0)               

# # Predict mean occupancy and also detection by method
# # Put all predictions into a single object
# str( tmp <- out10$sims.list )              # grab MCMC samples
# nsamp <- length(tmp[[1]])    # number of mcmc samples
# predC <- array(NA, dim = c(2, nsamp, 2)) # "C" for 'community mean'
# for(i in 1:nsamp){
#   predC[,i,1] <- plogis(tmp$mu.lpsi[i])
#   predC[,i,2] <- plogis(tmp$mu.lp[i] + tmp$mu.betalp1[i] * o.method)
# }

# Get posterior means and 95% CRIs and plot (Fig. 11?17)
# pmC <- apply(predC, c(1,3), mean)
# criC <- apply(predC, c(1,3), function(x) quantile(x, prob = c(0.025, 0.975)))
# 
# # these are the "community mean" psi and p
# mean_preds <-
#   data.frame(
#     metric = c(
#       "mean occupancy",
#       "Roller",
#       "Soil"
#     ),
#     mean = c(pmC[1, 1], pmC[, 2]),
#     q2.5 = c(criC[1, 1, 1], criC[1, , 2]),
#     q97.5 = c(criC[2, 1, 1], criC[2, , 2])
#   )

```
# Create Fig. 4 - DR community occupancy plot
```{r}
# load Part A of model run
DR_psi._p.method_partA <-
  readRDS("output/DR_psi._p.method_partA2.rds")

# load Part B of model run
DR_psi._p.method_partB <-
  readRDS("output/DR_psi._p.method_partB2.rds")

# Put output from 3 chains into a matrix
all10 <- as.matrix(DR_psi._p.method_partB)
str(all10)                    # look at the MCMC output

# Get posterior means and 95% CRIs
pm <- apply(all10, 2, mean)
cri <- apply(all10, 2, function(x) quantile(x, prob = c(0.025, 0.975))) 

p_roller_mat <- matrix(NA, ncol = 16, nrow = 6000)
p_soil_mat <- matrix(NA, ncol = 16, nrow = 6000)
psi_mat <- matrix(NA, ncol = 16, nrow = 6000)
for(i in 1:16){
  betalp1 <- all10[,i]
  lp <- all10[,i+41]
  lpsi <- all10[,i+81]
  p_roller_mat[,i] <- plogis(lp + betalp1)
  p_soil_mat[,i] <- plogis(lp)
  psi_mat[,i] <- plogis(lpsi)
}

# p Beta plot data for
naive_occ <- apply(apply(m_sp_detnon[, , c(1,3,5:12,14:15,18:21)], c(1, 3), max, na.rm = T), 2, sum)/21

sp_beta_plot <- data.frame(par = names(pm)[1:16], beta = pm[1:16],
           beta_q2.5 = cri[1,][1:16],
           beta_q97.5 = cri[2,][1:16],
           p_roller = apply(p_roller_mat, 2, mean),
           p_roller_q2.5 = 
             apply(p_roller_mat, 2, function(x) quantile(x, prob = c(0.025, 0.975)))[1,],
           p_roller_q97.5 = 
             apply(p_roller_mat, 2, function(x) quantile(x, prob = c(0.025, 0.975)))[2,],
           p_soil = apply(p_soil_mat, 2, mean),
           p_soil_q2.5 = 
             apply(p_soil_mat, 2, function(x) quantile(x, prob = c(0.025, 0.975)))[1,],
           p_soil_q97.5 = 
             apply(p_soil_mat, 2, function(x) quantile(x, prob = c(0.025, 0.975)))[2,],
           psi = apply(psi_mat, 2, mean),
           psi_q2.5 = 
             apply(psi_mat, 2, function(x) quantile(x, prob = c(0.025, 0.975)))[1,],
           psi_q97.5 = 
             apply(psi_mat, 2, function(x) quantile(x, prob = c(0.025, 0.975)))[2,]) %>%
  mutate(species = colnames(m_sp)[c(1,3,5:12,14:15,18:21)+4]) %>%
  mutate(species = gsub(species, 
                        pattern = "_", replacement = " ")) %>%
  mutate(species = forcats::fct_reorder(species, p_roller),
         naive_occ = naive_occ,
         arboreal = c("*", "*", "", "", "", "", "*", "", 
                      "*", "*", "*", "*", "", "", "*", ""),
         species = paste0(species, arboreal),
         species = forcats::fct_reorder(species, p_roller))

# Plot effect size of roller vs. soil by species
(beta_plot <- sp_beta_plot %>%
  ggplot() +
  geom_vline(xintercept = DR_psi._p.method_partA$summary[6,1],
             color = "red") +
  geom_vline(xintercept = DR_psi._p.method_partA$summary[6,c(3)],
             color = "red", lty = 2) +
  geom_vline(xintercept = DR_psi._p.method_partA$summary[6,c(7)],
             color = "red", lty = 2) +
  geom_errorbar(aes(xmin = beta_q2.5, 
                    xmax = beta_q97.5, y = species),
                width = 0, color = "black", size = .75) +
  geom_point(aes(x = beta, y = species), size = 3.5) +
  geom_vline(xintercept = 0, lty = 3) +
  theme_bw() +
  theme(text = element_text(size = 15)) +
  labs(x = sprintf('\U03B2 (roller vs. soil)'), y = "")
)

# ggsave("figures/roller_vs_soil_effect_size3.png", height = 5,
#        width = 7, dpi = 400)

# Plot phat for roller vs. soil by species
sp_p_plot <- sp_beta_plot %>%
  select(species, starts_with("p_r")) %>%
  rename(p_soil = p_roller, p_soil_q2.5 = p_roller_q2.5,
         p_soil_q97.5 = p_roller_q97.5) %>%
  bind_rows(select(sp_beta_plot, species, starts_with("p_s"))) %>%
  rename(p = 2, q2.5 = 3, q97.5 = 4) %>%
  mutate(Method = c(rep("Roller", 16), rep("Soil", 16)))

(p_plot <- sp_p_plot %>%
  ggplot() +
  geom_errorbar(aes(xmin = q2.5, 
                    xmax = q97.5, y = species, color = Method),
                width = 0, size = .75,
             position = position_dodge(width = .75)) +
  geom_point(aes(x = p, y = species, shape = Method), 
             size = 3.5, fill = "white",
             # color = sp_p_plot$soil_color,
             position = position_dodge(width = .75)) +
  scale_shape_manual(values = c(16, 21)) +
  scale_color_manual(values = c("black", "black")) +
  #cowplot::theme_cowplot() +
  theme_bw() +
  theme(text = element_text(size = 15),
        legend.position = c(0.81,0.13),
        legend.background = element_rect(color = "black"),
        axis.text.y = element_blank()) +
  labs(x = "Detection probability", y = "")
)

# ggsave("figures/roller_vs_soil_p.png", height = 5,
#        width = 7, dpi = 400)

# version without psi included
dev.new(width = 7, height = 5)
the_plot <- gridExtra::grid.arrange(beta_plot, p_plot, ncol = 2)
# ggsave("figures/Fig4_occ_plot5e.png", plot = the_plot, width = 7, height = 5, dpi = 400)
```
# Create Fig. 5 (left panel) - cumulative detection probability of flying squirrel, metabarcoding
Note: currently, to run this, you need to first create p_roller_mat etc up in the chunk where the detection probabilities are plotted by species.
```{r}
roller_cumulative = matrix(NA, nrow = 6000, ncol = 15)
niter = 6000
for(i in 1:niter){
  for(j in 1:15){
  roller_cumulative[i,j] <- 1-(1-p_roller_mat[i,9])^j
  }
}

soil_cumulative = matrix(NA, nrow = 6000, ncol = 15)
niter = 6000
for(i in 1:niter){
  for(j in 1:15){
  soil_cumulative[i,j] <- 1-(1-p_soil_mat[i,9])^j
  }
}

fs_soil_roller <- 
apply(roller_cumulative, 2, 
      function(x) quantile(x, c(0.025, 0.1, 0.5, 0.9, 0.975))) %>%
  cbind(apply(soil_cumulative, 2, 
      function(x) quantile(x, c(0.025, 0.1, 0.5, 0.9, 0.975)))) %>%
  t() %>%
  as.data.frame() %>%
  rename(q2.5 = 1, q10 = 2, med = 3, q90 = 4, q97.5 = 5) %>%
  mutate(Method = c(rep("Roller\n(metabarcoding)", 15), rep("Soil\n(metabarcoding)", 15)),
         n = c(1:15, 1:15))

(flying_squirrel <- 
    fs_soil_roller %>%
  ggplot() +
  geom_hline(yintercept = 0.95, lty = 2, 
             color = "darkgray") +
  geom_line(aes(x = n, y = med, lty = Method),
            size = .75) +
  geom_ribbon(aes(x = n, ymin = q2.5, ymax = q97.5,
                  group = Method), 
              alpha = 0.25, fill = "darkgray") +
  # geom_ribbon(aes(x = n, ymin = q10, ymax = q90,
  #                 group = Method), 
  #             alpha = 0.25, fill = "darkgray") +
  theme_bw() +
  theme(text = element_text(size = 14),
        legend.position = c(.7, 0.15),
        legend.background = element_rect(fill = "transparent")) +
  scale_x_continuous(breaks = seq(2, 14, 2)) +
  scale_y_continuous(limits = c(0,1)) +
  labs(y = "Cumulative detection probability",
       x = "Number of sampling visits",
       title = "Southern Flying Squirrel",
       fill = "",
       lty = "")
)

# ggsave("figures/flysquirrel_cumulative_p.png", 
#        width = 4, height = 4,
#        dpi = 400)

```
# Get information for Table S2 
how many trees (and visits per tree) for each method
```{r}
sites <- read.csv("data/sites.csv")

s <- m_sp %>%
  left_join(sites)

s %>%
  group_by(loc, method) %>%
  summarise(across(American_Red_Squirrel:`Yellow-rumped_Warbler`, list(mean, length, function(x) 100*sum(x>0)/length(x)))) %>%
  t()

# how many trees (and visits per tree) for each method
table(s$loc, s$site)
```
# Data formatting for multi-method occupancy modeling in JAGS
qPCR vs. metabarcoding
```{r}
# the qPCR data
q <- read.csv("data/qPCR_data_raw.csv") %>%
  filter(Sample.Type %in% c("Roller", "Soil")) %>%
  select(1:2, vol = 3, cleaned = 6, metabarcoded = 7, firstrun = 9,
         secondrun = 10, results = 14) %>%
  filter(firstrun!="") %>%
  mutate(
    pos = case_when(results == "" ~ 0,
                         substr(results,1,1)!="" ~ 
                           as.numeric(substr(results,1,1))),
         tot = case_when(results == "" ~ 3,
                         substr(results,1,1)!="" ~ 
                           as.numeric(substr(results,3,3))),
         tree = substr(treeid, 1, 3),
         visit = substr(treeid, 4, 4),
         method = case_when(Sample.Type == "Roller" ~ "R",
                            Sample.Type == "Soil" ~ "S")) %>%
  arrange(tree, method, visit)

# joining with the metabarcoding data
met <- m_sp %>%
  select(1:4,28, met = Big_Brown_Bat) %>%
  left_join(q, by = c("tree", "visit", "method")) %>%
  # these create detect/non-detect columns for qPCR technical reps
  # order doesn't matter in model
  mutate(q1 = case_when(pos>0 ~ 1,
                        pos==0 ~ 0),
         q2 = case_when(pos>1 ~ 1,
                        pos<2 ~ 0),
         q3 = case_when(pos>2 ~ 1,
                        pos<3 ~ 0),
         q4 = case_when(pos>3 ~ 1,
                        pos<3 & tot==3 ~ NaN,
                        pos<3 & tot==6 ~ 0),
         q5 = case_when(pos>4 ~ 1,
                        pos<4 & tot==3 ~ NaN,
                        pos<4 & tot==6 ~ 0),
         q6 = case_when(pos>5 ~ 1,
                        pos<5 & tot==3 ~ NaN,
                        pos<5 & tot==6 ~ 0),
         q_det = case_when(pos>0 ~ 1,
                           pos==0 ~ 0),
         met = case_when(met > 0 ~ 1,
                         met == 0 ~ 0)
         )

# make matrices for mutlimethod occupancy model

n_methods <- 2 # 1 metabarcoding sample + 1 detect/non-detect for qPCR

# create array for multispecies occupancy modelling
# dims: sites, visits, methods (qPCR or metabarcode) 
# note: could use "reactions" as 3 dimension: 1-6 qpcr tech reps, 1 metabarcode trial
multi_array <- array(NA, dim = c(n_trees, n_visits, n_methods)) 

for(s in 1:n_methods){
  for(samp in 1:n_samples){
    tree_num <- as.numeric(as.factor(met$tree))[samp]
    samp_num <- met$samp_num[samp]
    met2 <- met[,c(6,23)]
      multi_array[tree_num, samp_num, s] <- 
        as.numeric(met2[samp, s])
      }
}
# note: metabarcoding matrix is same as y_mam[,,2]

# rename array
y_multi = multi_array

# Create matrix of sampling method covariate for visit-level DNA "capture"
method = method_mat 
method[is.na(method)] <- 99999

# Create array of device covariate for observation-level detection
device = array(c(rep(1, 126), rep(0, 126)), dim = c(21, 6, 2))

# Bundle and summarize data set
jags.data.multimethod <- list(y = y_multi, 
                           n.trees = nrow(y_multi), 
                           n.samps = ncol(y_multi), 
                           n.device = dim(y_multi)[3],
                           method = method, 
                           device = device)
```
# Define Bayesian multi-method occupancy model in JAGS
JAGS code modified from Kéry & Royle (2015, pp. 606-607).

Kéry, M., & Royle, J. A. (2015). Applied Hierarchical Modeling in Ecology: Analysis of distribution, abundance and species richness in R and BUGS: Volume 1: Prelude and Static Models. London: Academic Press. 
```{r}
sink("scripts/mammal_multimethod.txt")
cat("
model {

# Priors and model for params
int.psi ~ dunif(0,1)         # Intercept of occupancy probability
gamma0 <- logit(int.psi)       # same on logit scale

int.theta ~ dunif(0,1)       # Intercept plot-level occupancy probability
beta0 <- logit(int.theta)      # same on logit scale
beta.method ~ dnorm(0, 0.1)   # sampling method covariate on logit(plot-level occupancy)

int.p ~ dunif(0,1)           # Intercept detection probability
alpha0 <- logit(int.p)         # same on logit scale
alpha.device ~ dnorm(0, 0.1) # Device covariate on logit(detection)

# Likelihood
for (i in 1:n.trees){
   # Occurrence at tree i
   z[i] ~ dbern(psi[i])
   logit(psi[i]) <- gamma0
   for (j in 1:n.samps){
      # Occurrence in sample j
      a[i,j] ~ dbern(z[i] * theta[i,j])
      logit(theta[i,j]) <- beta0 + beta.method * method[i,j]
      for (k in 1:n.device){
         # detection error process for device k
         y[i,j,k] ~ dbern(a[i,j] * p[i,j,k])
         logit(p[i,j,k]) <- alpha0 + alpha.device * device[i,j,k]
      }
   }
 }

# Derived quantities
# tree-level occupancy
logit(psi.tree) <- gamma0
# visit-level capture efficiency for roller
logit(theta.roller) <- beta0 + beta.method
# visit-level capture efficiency for soil
logit(theta.soil) <- beta0
# detection probability given capture for metabarcoding
logit(p.meta) <- alpha0 + alpha.device
# detection probability given capture for qPCR
logit(p.qpcr) <- alpha0

# Cumulative tree-level p for 1-30 visits (metabarcoding / roller)
for(i in 1:30){
p_tree_meta_roller[i] <- (1 - (1 - p.meta * theta.roller)^i)
}

# Cumulative tree-level p for 1-30 visits (qpcr / roller)
for(i in 1:30){
p_tree_qpcr_roller[i] <- (1 - (1 - p.qpcr * theta.roller)^i)
}


# 
# # visits required to reach 95% certainty of detect at occ trees
# still unmodified from vineyard SLF analysis
# n_eDNA_r1 <- log(20) / (-log(1 - p.eDNA * theta.round1))
# n_eDNA_r2 <- log(20) / (-log(1 - p.eDNA * theta.round2))
# n_vis_r1 <- log(20) / (-log(1 - p.vis * theta.round1))
# n_vis_r2 <- log(20) / (-log(1 - p.vis * theta.round2))

}
",fill=TRUE)
sink()
```
# Run Bayesian multi-method occupancy model in JAGS
Run time is approximately 30 seconds with parallel = T.
```{r}
# Initial values
y_no_na <- y_multi
y_no_na[is.na(y_no_na)] <- 0

inits <- function() list(z = apply(y_multi, 1, max, na.rm = T), 
                         # inits for presence (z)
                         a = apply(y_no_na, c(1,2), max), 
                         # inits for availability (a)
                         int.psi = runif(1), 
                         int.theta = runif(1),
                         int.p = runif(1), 
                         beta.method = rnorm(1, -2, 1),
                         alpha.device = rnorm(1, 2, 1))

# Parameters monitored
params <- c("gamma0", "beta0", "beta.method", "alpha0", "alpha.device",
            "psi.tree", "theta.roller", "theta.soil",
            "p.meta", "p.qpcr", "p_tree_meta_roller",
            "p_tree_qpcr_roller")

#####################################
#### Run jags model
#####################################
mammal_multimethod <- jagsUI::jags(data = jags.data.multimethod,
                         inits = inits,
                         parameters.to.save = params,
                         model.file = "scripts/mammal_multimethod.txt",
                         n.chains = 3,
                         n.adapt = NULL,
                         n.burnin = 10000,
                         n.iter = 50000,
                         n.thin = 10,
                         parallel = T,
                         verbose = TRUE,
                         modules = NULL)

# Examine model output
mammal_multimethod

# dev.new()
# plot(mammal_multimethod)

# Examine traceplots
# jagsUI::traceplot(NJ_vineyards_multimethod)

# saveRDS(mammal_multimethod, 
#         "output/mammal_multimethod_mod_20220614.rds")

```
# Create cumulative detection prob figure (meta vs qPCR)
Graph cumulative probability of detection in occupied trees with increasing survey effort. 
```{r}
# load multimethod occupancy model
mammal_multimethod <- 
  readRDS("output/mammal_multimethod_mod_20220614.rds")

# load function to summarize posteriors
source("scripts/sum_posts_function.R")

# format data
pv_all <- rbind.data.frame(
sum_posts(mammal_multimethod$sims.list$p_tree_meta_roller, "Roller\n(metabarcoding)", "Roller"),
sum_posts(mammal_multimethod$sims.list$p_tree_qpcr_roller, "Roller\n(qPCR)", "Roller")
)

(brown_bat <- 
pv_all %>%
  filter(n < 16) %>%
  ggplot() +
  geom_hline(yintercept = 0.95, lty = 2, 
             color = "darkgray") +
  # geom_ribbon(aes(x = n, ymin = q10, ymax = q90, fill = Method), 
  #             alpha = 0.5, color = "transparent") +
  geom_ribbon(aes(x = n, ymin = q2.5, ymax = q97.5, fill = Method), 
              alpha = 0.25, color = "transparent") +
  scale_fill_manual(values = c("darkgray", "darkgray")) +
  geom_line(aes(x = n, y = q50, color = Method, 
                linetype = Method), size = 0.75) +
  scale_linetype_manual(values = c(1,4)) +
  scale_color_manual(values = c("black", "black")) +
  # facet_wrap(~Round) +
  labs(y = "", 
       x = "Number of sampling visits",
       title = "Big Brown Bat",
       lty = "",
       color = "") +
  theme_bw() +
  guides(fill = "none") +
  theme(text = element_text(size = 14),
        legend.position = c(.7, 0.15),
        legend.background = element_rect(fill = "transparent")) + 
  scale_x_continuous(breaks = c(2,4,6,8,10,12,14)) +
  scale_y_continuous(limits = c(0,1))
)

# ggsave("Fig_2_vineyard_cumulative_detection_Bayes.pdf", width = 7, height = 6, dpi = 600, device=cairo_pdf)

# version with Flying Squirrel and Brown Bat side-by-side
# dev.new(width = 10, height = 4)
the_plot <- gridExtra::grid.arrange(flying_squirrel, 
                                    brown_bat, 
                                    ncol = 2)
ggsave("figures/squirrel_bat_cummulative_p4.png", 
       plot = the_plot, width = 7, 
       height = 5, dpi = 400)
```
# Calculate stats on qPCR vs. metabarcoding (big brown bat)
```{r}
# load multimethod occupancy model
mammal_multimethod <- 
  readRDS("output/mammal_multimethod_mod_20220614.rds")

hist(mammal_multimethod$sims.list$p.qpcr)
hist(mammal_multimethod$sims.list$p.meta)
quantile(mammal_multimethod$sims.list$p.qpcr, c(0.025, 0.5, 0.975))
quantile(mammal_multimethod$sims.list$p.meta, c(0.025, 0.5, 0.975))
mammal_multimethod$q50$p.qpcr/mammal_multimethod$q50$p.meta # 3.4

# how many samples brown bat detected by any method
sum(apply(y_multi, c(1,2), sum, na.rm = T)>0) # 11

# how many trees brown bat detected by any method # 7
sum(apply(y_multi, c(1), max, na.rm = T))

```
# Characterizing which soil samples were used
```{r}
mam <- m_sp[,c(1:4,c(1,3,5:12,14:15,18:21)+4)]

# how many trees had at least 1 roller positive
which_trees_roller_pos <- m_sp %>% 
  filter(method == "R") %>%
  dplyr::select(tree, 'American_Red_Squirrel':'Yellow-rumped_Warbler') %>%
  group_by(tree) %>%
  summarize_all(max) %>%
  ungroup() %>%
  select('American_Red_Squirrel':'Yellow-rumped_Warbler') %>%
  as.matrix()

apply(which_trees_roller_pos, 1, sum) 
# trees 7 and 9 lacked roller reads

# create arrays for counting roller samples
# dims: sites, visits, species 
n_trees = 21; n_visits = 3; n_spec = 23
m_sp_array_roll <- array(NA, dim = c(n_trees, n_visits, n_spec))
m_sp_roll <- m_sp %>% filter(method == "R")
for(s in 1:n_spec){
  for(samp in 1:nrow(m_sp_roll)){
    tree_num <- as.numeric(substr(m_sp_roll$tree,2,3))[samp]
    visit <- as.numeric(as.factor(m_sp_roll$visit))[samp]
    m_sp_array_roll[tree_num, visit, s] <- 
        as.numeric(m_sp_roll[samp, s+4])
      }
  }

# create array for counting soil samples
# dims: sites, visits, species 
n_trees = 21; n_visits = 3; n_spec = 23
m_sp_array_soil <- array(NA, dim = c(n_trees, n_visits, n_spec))
m_sp_soil <- m_sp %>% filter(method == "S")
for(s in 1:n_spec){
  for(samp in 1:nrow(m_sp_soil)){
    tree_num <- as.numeric(substr(m_sp_soil$tree,2,3))[samp]
    visit <- as.numeric(as.factor(m_sp_soil$visit))[samp]
    m_sp_array_soil[tree_num, visit, s] <- 
        as.numeric(m_sp_soil[samp, s+4])
      }
  }


# where were soil samples taken?
test_soil <- apply(m_sp_array_soil, c(1,2), sum)
test_roll <- apply(m_sp_array_roll, c(1,2), sum)
write.csv(test_soil, "output/soil_sum_reads.csv")
write.csv(test_roll, "output/roll_sum_reads.csv")

test_roll[is.na(test_soil)==F]
test_roll[test_roll==0]
```
# Create Fig. S1.
Code modified from:
https://rstudio-pubs-static.s3.amazonaws.com/694016_e2d53d65858d4a1985616fa3855d237f.html
```{r}
# load packages
library(vegan)
library(BiodiversityR)

# create df from which to make community-by-species matrix
m_sp_mean <- m_sp %>%
  group_by(site) %>%
  select_if(is.numeric) %>%
  summarize_all(mean) %>%
  select(-samp_num)

# remove observations with no species detected
m_sp_mean_no_blanks <-
  m_sp_mean[rowSums(m_sp_mean[,2:ncol(m_sp_mean)])>0,] %>%
  mutate(tree = paste0("T", substr(site, 2,3)),
         method = 
           substr(m_sp_mean[rowSums(m_sp_mean[,2:ncol(m_sp_mean)])>0,]$site,1,1)) %>%
  left_join(select(samps2, tree, Location)) %>%
  rename(Method = method, Site = Location) %>%
  mutate(Method = case_when(Method == "R" ~ "Roller",
                            TRUE ~ "Soil"), 
         Site = case_when(Site == "Morristown" ~ "Morristown",
                            TRUE ~ "Rutgers"), )
env.data <- m_sp_mean_no_blanks %>%
  select("tree":"Site")

# create community-by-species matrix
m_sp_mean_no_blanks_mat <- m_sp_mean_no_blanks %>%
  select("American_Red_Squirrel":"Yellow-rumped_Warbler") %>%
  as.matrix()

# subset community-by-species matrix to just mammals
m_sp_mean_no_blanks_mat_mam <- 
  m_sp_mean_no_blanks_mat[,c(1,3,5,6,7,8,9,10,11,12,14,15,18,19,20,21)]

# run NMDS
mammal_NMDS=metaMDS(m_sp_mean_no_blanks_mat_mam, 
                    # Our community-by-species matrix (just mammals)
                     k=2, distance = 'bray', trymax = 100) 
# k = number of reduced dimensions. Increase if high stress is problem. 

# format NMDS results for plotting
plot1 <- ordiplot(mammal_NMDS, choices = c(1, 2))
sites.long1 <-
  BiodiversityR::sites.long(plot1, env.data = env.data) %>%
  mutate(axis1 = as.numeric(axis1),
         axis2 = as.numeric(axis2),
         order = case_when(Site == "Rutgers" ~ 1,
                           TRUE ~ 2),
         Site = forcats::fct_reorder(Site, order))
head(sites.long1)
str(sites.long1)

# create ellipses
  veganCovEllipse<-function (cov, center = c(0, 0), scale = 1, npoints = 100) 
  {
    theta <- (0:npoints) * 2 * pi/npoints
    Circle <- cbind(cos(theta), sin(theta))
    t(center + scale * t(Circle %*% chol(cov)))
  }
  df_ell <- data.frame()
  for(g in levels(as.factor(sites.long1$Site))){
    df_ell <- rbind(df_ell, cbind(as.data.frame(with(sites.long1[sites.long1$Site==g,],
                    veganCovEllipse(cov.wt(cbind(axis1,axis2),wt=rep(1/length(axis1),length(axis1)))$cov,center=c(mean(axis1),mean(axis2)))))
                    ,Site=g))
  }
# make the plot
(nmds_plot <- ggplot(sites.long1) +
  geom_vline(xintercept = c(0),
             color = "grey70",
             linetype = 2) +
  geom_hline(yintercept = c(0),
             color = "grey70",
             linetype = 2) +     
  xlab("NMDS1") +
  ylab("NMDS2") +
  scale_x_continuous(sec.axis = dup_axis(labels = NULL, name = NULL)) +
  scale_y_continuous(sec.axis = dup_axis(labels = NULL, name = NULL)) +
  geom_point(aes(
    x = axis1,
    y = axis2,
    shape = Method,
    color = Site
  ),
  size = 5) +
    geom_path(data=df_ell, aes(x=axis1, y=axis2, color = Site), size=1, linetype=2)+
  theme_bw() +
  theme(text = element_text(size = 14)) +
  scale_color_manual(values = c("firebrick", "steelblue")) +
  coord_fixed(ratio = 1)
)
ggsave("figures/FigS1_reads_ordination_by_method_site.png", 
       height = 6, width = 6, dpi = 400)
```
# Community occupancy model on reduced data set (1:1 roller/soil samples)
Community occupancy model on only mammals, omitting any roller samples that do not have a corresponding soil sample. Code adapted from Kery and Royle, AMH 1 book, section 11.7.2.
```{r}
# update n species
nspec.r <- dim(y_mam.r)[3]
# Augment data set: choose one of two different priors on Ntotal
nz.r <- 40 - nspec.r         # Use for informative prior on Ntotal: M = ~40 ("dozens of mammal species" - NJDEP)


# changing NA in method matrix to 0 so model can run 
# (not actually missing)
method_mat0.r <- method_mat.r; method_mat0.r[is.na(method_mat0.r)] <- 0

nsite.r <- n_trees.r; nrep.r <- n_visits.r
yaug.r <- array(0, dim=c(nsite.r, nrep.r, nspec.r+nz.r)) # array with only zeroes
yaug.r[,,1:nspec.r] <- y_mam.r      # copy into it the observed data

# Create same NA pattern in augmented species as in the observed species
missings.r <- is.na(yaug.r[,,1]) 
for(k in (nspec.r+1):(nspec.r+nz.r)){
  yaug.r[,,k][missings.r] <- NA
}

# Bundle and summarize data
str(win.data.r <- list(y = yaug.r, nsite = dim(y_mam.r)[1], nrep = dim(y_mam.r)[2], nspec = dim(y_mam.r)[3], nz = nz.r, M = nspec.r + nz.r, method = method_mat0.r) )

# Initial values
wst <- rep(1, nspec.r+nz.r)       # Simply set everybody at occurring
zst <- array(1, dim = c(nsite.r, nspec.r+nz.r)) # ditto
inits <- function() list(z = zst, w = wst, lpsi = rnorm(n = nspec.r+nz.r), betalpsi1 = rnorm(n = nspec.r+nz.r), betalpsi2 = rnorm(n = nspec.r+nz.r), betalpsi3 = rnorm(n = nspec.r+nz.r), lp = rnorm(n = nspec.r+nz.r), betalp1 = rnorm(n = nspec.r+nz.r), betalp2 = rnorm(n = nspec.r+nz.r), betalp3 = rnorm(n = nspec.r+nz.r))

# Set 1
params1 <- c("omega", "mu.lpsi", "sd.lpsi", "mu.betalpsi1", "sd.betalpsi1", "mu.betalpsi2", "sd.betalpsi2", "mu.betalpsi3", "sd.betalpsi3", "mu.lp", "sd.lp", "mu.betalp1", "sd.betalp1", "mu.betalp2", "sd.betalp2", "mu.betalp3", "sd.betalp3", "Ntotal", "Nsite")

# MCMC settings
ni <- 30000   ;   nt <- 10   ;   nb <- 10000   ;   nc <- 3

# Run JAGS, check convergence and summarize posteriors
# DR_psi._p.method_partA.r <- jagsUI::jags(win.data.r, inits, params1, 
#                "scripts/DR_psi._p.method.txt", 
#                n.chains = nc, n.thin = nt, n.iter = ni, 
#                n.burnin = nb, parallel = TRUE)

DR_psi._p.method_partA.r
# dev.new(6,6); plot(DR_psi._p.method_partA.r)

# saveRDS(DR_psi._p.method_partA.r,
#         "output/DR_psi._p.method_partA.r.rds")

DR_psi._p.method_partA.r <-
  readRDS("output/DR_psi._p.method_partA.r.rds")

# Set 2
params2 <- c("mu.lp", "sd.lp", "mu.betalp1", "sd.betalp1", "mu.lpsi", "sd.lpsi", "mu.betalpsi1", "sd.betalpsi1", "mu.betalpsi2", "sd.betalpsi2", "mu.betalpsi3", "sd.betalpsi3", "lpsi", "betalpsi1", "betalpsi2", "betalpsi3", "lp", "betalp1", "betalp2", "betalp3", "z", "w")
ni <- 30000   ;   nt <- 10   ;   nb <- 10000   ;   nc <- 3

# DR_psi._p.method_partB.r <- jagsUI::jags(win.data.r, inits, params2, "scripts/DR_psi._p.method.txt", n.chains = nc, n.thin = nt, n.iter = ni, n.burnin = nb, parallel = TRUE)

# saveRDS(DR_psi._p.method_partB.r,
#         "output/DR_psi._p.method_partB.r.rds")
DR_psi._p.method_partB.r <-
  readRDS("output/DR_psi._p.method_partB.r.rds")

# dev.new(6,6); plot(DR_psi._p.method_partB.r)

# library(coda)
# Put output from 3 chains into a matrix
all10 <- as.matrix(DR_psi._p.method_partB.r) 
 summary(DR_psi._p.method_partB.r)            # May take a loooong time
# gelman.diag(DR_psi._p.method_partB)        # ditto

# Visualize covariate mean relationships for the average species
# Get covariate values for prediction
o.method <- c(1,0)               

# Predict mean detection by method
# Put all predictions into a single object
str( tmp <- DR_psi._p.method_partA.r$sims.list )   # grab MCMC samples
nsamp <- length(tmp[[1]])    # number of mcmc samples
predC <- array(NA, dim = c(2, nsamp, 2)) # "C" for 'community mean'
for(i in 1:nsamp){
  predC[,i,1] <- plogis(tmp$mu.lpsi[i])
  predC[,i,2] <- plogis(tmp$mu.lp[i] + tmp$mu.betalp1[i] * o.method)
}

# Get posterior means and 95% CRIs and plot (Fig. 11?17)
pmC <- apply(predC, c(1,3), mean)
criC <- apply(predC, c(1,3), function(x) quantile(x, prob = c(0.025, 0.975)))

# these are the "community mean" psi and p
(mean_preds <-
  data.frame(
    metric = c(
      "mean occupancy",
      "Roller",
      "Soil"
    ),
    mean = c(pmC[1, 1], pmC[, 2]),
    q2.5 = c(criC[1, 1, 1], criC[1, , 2]),
    q97.5 = c(criC[2, 1, 1], criC[2, , 2])
  )
)
#           metric       mean        q2.5     q97.5
# 1 mean occupancy 0.48572247 0.005334791 0.9998115
# 2         Roller 0.20535570 0.060421784 0.4221118
# 3           Soil 0.05374295 0.013255311 0.1312966

predbeta <- DR_psi._p.method_partB.r$sims.list$betalp1[,1:14]

predbeta_df_tmp <- data.frame(
pm = apply(predbeta, 2, mean),
ll = apply(predbeta, 2, function(x) quantile(x, prob = c(0.025))),
ul = apply(predbeta, 2, function(x) quantile(x, prob = c(0.975))),
species = gsub(colnames(m_sp.r[,c(3,5:9,11:12,14:15,18:21)+4]), 
              pattern = "_", replacement = " ")
) %>%
  mutate(arboreal = c("*", "", "", "", "", "*", "*", "*", 
                      "*", "*", "", "", "*", ""),
         species = paste0(species, arboreal))

nmethods <- 2

tmp <- DR_psi._p.method_partB.r$sims.list
predp <- array(NA, dim = c(nsamp, nspec.r, nmethods))
for(i in 1:nsamp){
  for(j in 1:nspec.r){
    for(k in 1:nmethods){
  predp[i,j,k] <- plogis(tmp$lp[i,j] + tmp$betalp1[i,j] * o.method[k])
  }
}
}

predp_roll_df <- data.frame(
pm = apply(predp[,,1], 2, mean),
ll = apply(predp[,,1], 2, function(x) 
  quantile(x, prob = c(0.025))),
ul = apply(predp[,,1], 2, function(x) 
  quantile(x, prob = c(0.975))),
species = gsub(colnames(m_sp.r[,c(3,5:9,11:12,14:15,18:21)+4]), 
              pattern = "_", replacement = " ")
) %>% mutate(method = "Roller")

predp_soil_df <- data.frame(
pm = apply(predp[,,2], 2, mean),
ll = apply(predp[,,2], 2, function(x) 
  quantile(x, prob = c(0.025))),
ul = apply(predp[,,2], 2, function(x) 
  quantile(x, prob = c(0.975))),
species = gsub(colnames(m_sp.r[,c(3,5:9,11:12,14:15,18:21)+4]), 
              pattern = "_", replacement = " ")
) %>% mutate(method = "Soil")

predp_df <- predp_roll_df %>%
  bind_rows(predp_soil_df) %>%
  mutate(arboreal = rep(c("*", "", "", "", "", "*", "*", "*", 
                      "*", "*", "", "", "*", ""), 2),
         species = paste0(species, arboreal),
         species = forcats::fct_reorder(species, pm))


predbeta_df <- predbeta_df_tmp %>%
  left_join(filter(select(predp_df, species, method, p = pm), 
                   method == "Roller"), by = "species") %>%
  mutate(species = forcats::fct_reorder(species, p))

#  naive occupancy for plotting with psi
naive_occ.r <- apply(apply(m_sp_detnon.r[,,c(3,5:9,11:12,14:15,18:21)], c(1, 3), max, na.rm = T), 2, sum)/14

# Plot effect size of roller vs. soil by species
(beta_plot <- predbeta_df %>%
  ggplot() +
  geom_vline(xintercept = DR_psi._p.method_partA.r$summary[6,1],
             color = "red") +
  geom_vline(xintercept = DR_psi._p.method_partA.r$summary[6,c(3)],
             color = "red", lty = 2) +
  geom_vline(xintercept = DR_psi._p.method_partA.r$summary[6,c(7)],
             color = "red", lty = 2) +
  geom_errorbar(aes(xmin = ll, 
                    xmax = ul, y = species),
                width = 0, color = "black", size = .75) +
  geom_point(aes(x = pm, y = species), size = 3.5) +
  geom_vline(xintercept = 0, lty = 3) +
  theme_bw() +
  theme(text = element_text(size = 15)) +
  labs(x = sprintf('\U03B2 (roller vs. soil)'), y = "")
)

# ggsave("figures/roller_vs_soil_effect_size.r.png", height = 5,
#        width = 7, dpi = 400)

(p_plot <- predp_df %>%
  ggplot() +
  geom_errorbar(aes(xmin = ll, 
                    xmax = ul, y = species, color = method),
                width = 0, size = .75,
             position = position_dodge(width = .75)) +
  geom_point(aes(x = pm, y = species, shape = method), 
             size = 3.5, fill = "white",
             # color = sp_p_plot$soil_color,
             position = position_dodge(width = .75)) +
  scale_shape_manual(values = c(16, 21)) +
  scale_color_manual(values = c("black", "black")) +
  #cowplot::theme_cowplot() +
  theme_bw() +
  theme(text = element_text(size = 15),
        legend.position = c(0.81,0.13),
        legend.background = element_rect(color = "black"),
        axis.text.y = element_blank()) +
  labs(x = "Detection probability", y = "")
)

# ggsave("figures/roller_vs_soil_p.r.png", height = 5,
#        width = 7, dpi = 400)

# combine plots
dev.new(width = 7, height = 5)
the_plot <- gridExtra::grid.arrange(beta_plot, p_plot, ncol = 2)
# ggsave("figures/occ_plot5.r.png", plot = the_plot, width = 7, height = 5, dpi = 400)

DR_psi._p.method_partA.r$summary[6,1]
# [1] 1.570661
DR_psi._p.method_partA.r$summary[6,c(3)]
# [1] 1.025067
DR_psi._p.method_partA.r$summary[6,c(7)]
# [1] 2.165275
```
# cumulative detection probability (squirrel), reduced data set
flying squirrel, metabarcoding
Note: currently, to run this, you need to first create p_roller_mat etc up in the chunk where the detection probabilities are plotted by species.
```{r}

DR_psi._p.method_partA.r <-
  readRDS("output/DR_psi._p.method_partA.r.rds")

DR_psi._p.method_partB.r <-
  readRDS("output/DR_psi._p.method_partB.r.rds")

p_roller_mat.r <- predp[,,1]
p_soil_mat.r <- predp[,,2]
  
roller_cumulative = matrix(NA, nrow = 6000, ncol = 15)
niter = 6000
for(i in 1:niter){
  for(j in 1:15){
  roller_cumulative[i,j] <- 1-(1-p_roller_mat.r[i,7])^j
  }
}

soil_cumulative = matrix(NA, nrow = 6000, ncol = 15)
niter = 6000
for(i in 1:niter){
  for(j in 1:15){
  soil_cumulative[i,j] <- 1-(1-p_soil_mat.r[i,7])^j
  }
}

fs_soil_roller <- 
apply(roller_cumulative, 2, 
      function(x) quantile(x, c(0.025, 0.1, 0.5, 0.9, 0.975))) %>%
  cbind(apply(soil_cumulative, 2, 
      function(x) quantile(x, c(0.025, 0.1, 0.5, 0.9, 0.975)))) %>%
  t() %>%
  as.data.frame() %>%
  rename(q2.5 = 1, q10 = 2, med = 3, q90 = 4, q97.5 = 5) %>%
  mutate(Method = c(rep("Roller\n(metabarcoding)", 15), rep("Soil\n(metabarcoding)", 15)),
         n = c(1:15, 1:15))

(flying_squirrel <- 
    fs_soil_roller %>%
  ggplot() +
  geom_hline(yintercept = 0.95, lty = 2, 
             color = "darkgray") +
  geom_line(aes(x = n, y = med, lty = Method),
            size = .75) +
  geom_ribbon(aes(x = n, ymin = q2.5, ymax = q97.5,
                  group = Method), 
              alpha = 0.25, fill = "darkgray") +
  # geom_ribbon(aes(x = n, ymin = q10, ymax = q90,
  #                 group = Method), 
  #             alpha = 0.25, fill = "darkgray") +
  theme_bw() +
  theme(text = element_text(size = 14),
        legend.position = c(.7, 0.15),
        legend.background = element_rect(fill = "transparent")) +
  scale_x_continuous(breaks = seq(2, 14, 2)) +
  scale_y_continuous(limits = c(0,1)) +
  labs(y = "Cumulative detection probability",
       x = "Number of sampling visits",
       title = "Southern Flying Squirrel",
       fill = "",
       lty = "")
)

ggsave("figures/flysquirrel_cumulative_p.r.png", 
       width = 4, height = 4,
       dpi = 400)

# ~ 3 and ~ 11 samples required, respectively
```
# Species accumulation curves (reduced data set)
Code adapted from insect paper analysis. Originally adapted from here: https://rpubs.com/Roeland-KINDT/694021
and: http://biological-complexity.blogspot.com/2018/01/on-species-accumulation-curves.html
```{r}
# Make empty martices for the spp accumulation curves
roll_mat_1samp = matrix(NA, nrow = 14, ncol = 14)
soil_mat_1samp = matrix(NA, nrow = 14, ncol = 14)
both_mat_1samp = matrix(NA, nrow = 14, ncol = 14)

roll_mat_2samp = matrix(NA, nrow = 14, ncol = 14)
soil_mat_2samp = matrix(NA, nrow = 14, ncol = 14)
both_mat_2samp = matrix(NA, nrow = 14, ncol = 14)

roll_mat_3samp = matrix(NA, nrow = 14, ncol = 14)
soil_mat_3samp = matrix(NA, nrow = 14, ncol = 14)
both_mat_3samp = matrix(NA, nrow = 14, ncol = 14)

# Fill matrices with detection/nondetection data by tree and species
for(j in 1:14){
  print(paste0("species:",j))
for(i in 1:14){
roll_mat_1samp[i,j] = y_mam.r[i,,j][method_mat.r[i,]==1][1]
soil_mat_1samp[i,j] = y_mam.r[i,,j][method_mat.r[i,]==0][1]
both_mat_1samp[i,j] = max(roll_mat_1samp[i,j], soil_mat_1samp[i,j])

roll_mat_2samp[i,j] = max(y_mam.r[i,,j][method_mat.r[i,]==1][1:2])
soil_mat_2samp[i,j] = max(y_mam.r[i,,j][method_mat.r[i,]==0][1:2])
both_mat_2samp[i,j] = max(roll_mat_2samp[i,j], soil_mat_2samp[i,j])

roll_mat_3samp[i,j]=max(y_mam.r[i,,j][method_mat.r[i,]==1][1:3])
soil_mat_3samp[i,j]=max(y_mam.r[i,,j][method_mat.r[i,]==0][1:3])
both_mat_3samp[i,j] = max(roll_mat_3samp[i,j], soil_mat_3samp[i,j])
  }
}

# reduce roller data to include only samples w/ a matching soil sample
roll_mat_1samp[is.na(soil_mat_1samp)] <- NA
roll_mat_2samp[is.na(soil_mat_2samp)] <- NA
roll_mat_3samp[is.na(soil_mat_3samp)] <- NA

# remove rows with all NAs
roll_mat_1samp = roll_mat_1samp[is.na(roll_mat_1samp[,1])==F,]
roll_mat_2samp = roll_mat_2samp[is.na(roll_mat_2samp[,1])==F,]
roll_mat_3samp = roll_mat_3samp[is.na(roll_mat_3samp[,1])==F,]
soil_mat_1samp = soil_mat_1samp[is.na(soil_mat_1samp[,1])==F,]
soil_mat_2samp = soil_mat_2samp[is.na(soil_mat_2samp[,1])==F,]
soil_mat_3samp = soil_mat_3samp[is.na(soil_mat_3samp[,1])==F,]
both_mat_1samp = both_mat_1samp[is.na(both_mat_1samp[,1])==F,]
both_mat_2samp = both_mat_2samp[is.na(both_mat_2samp[,1])==F,]
both_mat_3samp = both_mat_3samp[is.na(both_mat_3samp[,1])==F,]

# run species accumulation curves
accum.roll1 <- accumcomp(roll_mat_1samp, 
                     y=data.frame(method = 
                                    rep("roll1",
                                        nrow(roll_mat_1samp))),
                     factor='method', 
  method='exact', conditioned=FALSE, plotit=FALSE)
accum.roll1

accum.roll2 <- accumcomp(roll_mat_2samp, 
                     y=data.frame(method = 
                                    rep("roll2",
                                        nrow(roll_mat_2samp))),
                     factor='method', 
  method='exact', conditioned=FALSE, plotit=FALSE)
accum.roll2

accum.roll3 <- accumcomp(roll_mat_3samp, 
                     y=data.frame(method = 
                                    rep("roll3",
                                        nrow(roll_mat_3samp))),
                     factor='method', 
  method='exact', conditioned=FALSE, plotit=FALSE)
accum.roll3

accum.soil1 <- accumcomp(soil_mat_1samp, 
                         y=data.frame(method = 
                                        rep("soil1",
                                            nrow(soil_mat_1samp))),
                         factor='method', 
                         method='exact', conditioned=FALSE, plotit=FALSE)
accum.soil1

accum.soil2 <- accumcomp(soil_mat_2samp, 
                         y=data.frame(method = 
                                        rep("soil2",
                                            nrow(soil_mat_2samp))),
                         factor='method', 
                         method='exact', conditioned=FALSE, plotit=FALSE)
accum.soil2

accum.soil3 <- accumcomp(soil_mat_3samp, 
                         y=data.frame(method = 
                                        rep("soil3",
                                            nrow(soil_mat_3samp))),
                         factor='method', 
                         method='exact', conditioned=FALSE, plotit=FALSE)
accum.soil3

accum.both1 <- accumcomp(both_mat_1samp, 
                         y=data.frame(method = 
                                        rep("both1",
                                            nrow(both_mat_1samp))),
                         factor='method', 
                         method='exact', conditioned=FALSE, plotit=FALSE)
accum.both1

accum.both2 <- accumcomp(both_mat_2samp, 
                         y=data.frame(method = 
                                        rep("both2",
                                            nrow(both_mat_2samp))),
                         factor='method', 
                         method='exact', conditioned=FALSE, plotit=FALSE)
accum.both2

accum.both3 <- accumcomp(both_mat_3samp, 
                         y=data.frame(method = 
                                        rep("both3",
                                            nrow(both_mat_3samp))),
                         factor='method', 
                         method='exact', conditioned=FALSE, plotit=FALSE)
accum.both3

# format results to plot the curves
plot.data.roll1 <- data.frame(samples = c(accum.roll1[,,1]), 
           s = c(accum.roll1[,,2]), 
           sd = c(accum.roll1[,,3]),
           method = "roll1")
plot.data.roll2 <- data.frame(samples = c(accum.roll2[,,1]), 
           s = c(accum.roll2[,,2]), 
           sd = c(accum.roll2[,,3]),
           method = "roll2")
plot.data.roll3 <- data.frame(samples = c(accum.roll3[,,1]), 
           s = c(accum.roll3[,,2]), 
           sd = c(accum.roll3[,,3]),
           method = "roll3")
plot.data.soil1 <- data.frame(samples = c(accum.soil1[,,1]), 
            s = c(accum.soil1[,,2]), 
            sd = c(accum.soil1[,,3]),
            method = "soil1")
plot.data.soil2 <- data.frame(samples = c(accum.soil2[,,1]), 
            s = c(accum.soil2[,,2]), 
            sd = c(accum.soil2[,,3]),
            method = "soil2")
plot.data.soil3 <- data.frame(samples = c(accum.soil3[,,1]), 
            s = c(accum.soil3[,,2]), 
            sd = c(accum.soil3[,,3]),
            method = "soil3")
plot.data.both1 <- data.frame(samples = c(accum.both1[,,1]), 
            s = c(accum.both1[,,2]), 
            sd = c(accum.both1[,,3]),
            method = "both1")
plot.data.both2 <- data.frame(samples = c(accum.both2[,,1]), 
            s = c(accum.both2[,,2]), 
            sd = c(accum.both2[,,3]),
            method = "both2")
plot.data.both3 <- data.frame(samples = c(accum.both3[,,1]), 
            s = c(accum.both3[,,2]), 
            sd = c(accum.both3[,,3]),
            method = "both3")

plot.data <- plot.data.roll1 %>%
  bind_rows(plot.data.roll2) %>%
  bind_rows(plot.data.roll3) %>%
  bind_rows(plot.data.soil1) %>%
  bind_rows(plot.data.soil2) %>%
  bind_rows(plot.data.soil3) %>%
  bind_rows(plot.data.both1) %>%
  bind_rows(plot.data.both2) %>%
  bind_rows(plot.data.both3) %>%
  mutate(method = as.factor(method),
         Method = substr(method, 1, 4),
         per_tree = paste0(substr(method, 5,5), 
                           " samples per tree")) %>%
  mutate(Method = case_when(Method == "both" ~ "Both",
                            Method == "roll" ~ "Roller",
                            Method == "soil" ~ "Soil"),
         per_tree = case_when(per_tree == "1 samples per tree" ~
                                "1 sample per tree",
                              TRUE ~ per_tree)) 
  
plot.data %>%
ggplot() +
  geom_ribbon(aes(x = samples, ymin = s-1*sd, 
                  ymax = s+1*sd, fill = Method, group = method),
              alpha = 0.5) +  
  geom_line(aes(x = samples, y = s, group = method, lty = Method), size = 1) +
  scale_fill_manual(values = c("darkgreen", "steelblue", "firebrick")) +
  facet_wrap(~per_tree) +
  theme_bw() +
  theme(text = element_text(size = 14),
        legend.position = c(.92,.15),
        legend.key.size = unit(.2, 'cm'),
        legend.background = element_rect(fill = "transparent"),
        strip.background = element_rect(fill = "white")) +
  labs(x = "No. trees sampled", y = "No. mammal species",
       fill = "Method")


ggsave("figures/species_accumulation_curve_roll_soil4.r.png",
       dpi = 600, width = 6, height = 4)
```