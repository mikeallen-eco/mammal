
model {

# Priors and model for params
int.psi ~ dunif(0,1)         # Intercept of occupancy probability
gamma0 <- logit(int.psi)       # same on logit scale

int.theta ~ dunif(0,1)       # Intercept plot-level occupancy probability
beta0 <- logit(int.theta)      # same on logit scale
beta.method ~ dnorm(0, 0.1)   # sampling method covariate on logit(plot-level occupancy)

int.p ~ dunif(0,1)           # Intercept detection probability
alpha0 <- logit(int.p)         # same on logit scale
alpha.device ~ dnorm(0, 0.1) # Device covariate on logit(detection)

# Likelihood
for (i in 1:n.trees){
   # Occurrence at tree i
   z[i] ~ dbern(psi[i])
   logit(psi[i]) <- gamma0
   for (j in 1:n.samps){
      # Occurrence in sample j
      a[i,j] ~ dbern(z[i] * theta[i,j])
      logit(theta[i,j]) <- beta0 + beta.method * method[i,j]
      for (k in 1:n.device){
         # detection error process for device k
         y[i,j,k] ~ dbern(a[i,j] * p[i,j,k])
         logit(p[i,j,k]) <- alpha0 + alpha.device * device[i,j,k]
      }
   }
 }

# Derived quantities
# tree-level occupancy
logit(psi.tree) <- gamma0
# visit-level capture efficiency for roller
logit(theta.roller) <- beta0 + beta.method
# visit-level capture efficiency for soil
logit(theta.soil) <- beta0
# detection probability given capture for metabarcoding
logit(p.meta) <- alpha0 + alpha.device
# detection probability given capture for qPCR
logit(p.qpcr) <- alpha0

# Cumulative tree-level p for 1-30 visits (metabarcoding / roller)
for(i in 1:30){
p_tree_meta_roller[i] <- (1 - (1 - p.meta * theta.roller)^i)
}

# Cumulative tree-level p for 1-30 visits (qpcr / roller)
for(i in 1:30){
p_tree_qpcr_roller[i] <- (1 - (1 - p.qpcr * theta.roller)^i)
}

}

